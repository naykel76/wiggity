# GitHub Copilot Custom Instructions

## Technology Stack
- **Framework**: Laravel 12 (PHP 8.2+)
- **Frontend**: Livewire 3, Blade templates, Alpine.js
- **Testing**: Pest PHP
- **Code Quality**: Laravel Pint (PHP CS Fixer)
- **Database**: MySQL/PostgreSQL (standard Laravel setup)
- **Build Tools**: Vite

## Custom Packages Used
- `naykel/authit`: Authentication package
- `naykel/contactit`: Contact forms
- `naykel/gotime`: Date/time utilities
- `naykel/payit`: Payment processing
- `naykel/postit`: Post/content management
- `naykel/devit`: Development utilities


## ✅ General Coding Standards

-   Follow **PSR-12** coding style and structure.
-   Prefer short, expressive, and readable code.
-   Use **meaningful, descriptive variable, function, class, and file names**.
-   Apply proper PHPDoc blocks for classes, methods, and complex logic.
-   Organize code into small, reusable functions or classes with single responsibility.
-   Avoid magic numbers or hard-coded strings; use constants or config files.

## ✅ PHP 8.2/8.4 Best Practices

-   Use **readonly properties** to enforce immutability where applicable.
-   Use **Enums** instead of string or integer constants.
-   Utilize **First-class callable syntax** for callbacks.
-   Leverage **Constructor Property Promotion**.
-   Use **Union Types**, **Intersection Types**, and **true/false return types** for strict typing.
-   Apply **Static Return Type** where needed.
-   Use the **Nullsafe Operator (?->)** for optional chaining.
-   Adopt **final classes** where extension is not intended.
-   Use **Named Arguments** for improved clarity when calling functions with multiple parameters.

## ✅ Laravel 12 Project Structure & Conventions

-   Follow the official Laravel project structure:

    -   `app/Http/Controllers` - Controllers
    -   `app/Models` - Eloquent models
    -   `app/Http/Requests` - Form request validation
    -   `app/Http/Resources` - API resource responses
    -   `app/Enums` - Enums
    -   `app/Services` - Business logic
    -   `app/Data` - Data Transfer Objects (DTOs)
    -   `app/Actions` - Single-responsibility action classes
    -   `app/Policies` - Authorization logic

-   Controllers must:

    -   Be thin.
    -   Use dependency injection.
    -   Use Form Requests for validation.
    -   Return typed responses (e.g., `JsonResponse`).
    -   Use Resource classes for API responses.

-   Business logic should reside in:
    -   Service classes
    -   Action classes
    -   Event listeners or Jobs for asynchronous tasks

## ✅ Eloquent ORM & Database

-   Use **Eloquent Models** with proper `$fillable` or `$guarded` attributes for mass assignment protection.
-   Utilize **casts** for date, boolean, JSON, and custom data types.
-   Apply **accessors & mutators** for attribute transformation.
-   Avoid direct raw SQL unless absolutely necessary; prefer Eloquent or Query Builder.
-   Migrations:
    -   Always use migrations for schema changes.
    -   Include proper constraints (foreign keys, unique indexes, etc.).

## ✅ API Development


## ✅ Security Best Practices

-   Never trust user input; always validate and sanitize inputs.
-   Use prepared statements via Eloquent or Query Builder to prevent SQL injection.
-   Use Laravel's built-in CSRF, XSS, and validation mechanisms.
-   Store sensitive information in `.env`, never hard-code secrets.
-   Apply proper authorization checks using Policies or Gates.
-   Follow principle of least privilege for users, roles, and permissions.

## ✅ Software Quality & Maintainability

-   Follow **SOLID Principles**:
-   Follow **DRY** (Don't Repeat Yourself) and **KISS** (Keep It Simple, Stupid) principles.
-   Document complex logic with PHPDoc and inline comments.

## ✅ Performance & Optimization

-   Eager load relationships to avoid N+1 queries.
-   Use caching with Laravel's Cache system for frequently accessed data.
-   Paginate large datasets using `paginate()` instead of `get()`.
-   Queue long-running tasks using Laravel Queues.
-   Optimize database indexes for common queries.

## ✅ Additional Copilot Behavior Preferences

-   Generate **strictly typed**, modern PHP code using latest language features.
-   Prioritize **readable, clean, maintainable** code over cleverness.
-   Avoid legacy or deprecated Laravel patterns (facade overuse, logic-heavy views, etc.).
-   Suggest proper class placement based on Laravel directory structure.
-   Suggest tests alongside new features where applicable.
-   Default to **immutability**, **dependency injection**, and **encapsulation** best practices.
-   Avoid starting responses with "Sure!", "You're right!" or similar phrases; be direct and concise.
-   When writing text that'll be visible to users, use **clear, professional language** without unnecessary exclamations or informalities. Also use Sentence case for titles and headings.

## Code Style and Conventions

### PHP/Laravel Standards
- Follow PSR-12 coding standards
- Use Laravel Pint for code formatting (`composer format`)
- Prefer explicit type declarations and return types
- Use strict typing (`declare(strict_types=1);`) for new files
- Follow Laravel naming conventions:
  - Models: PascalCase, singular (e.g., `User`, `ScheduledEvent`)
  - Controllers: PascalCase with Controller suffix
  - Migrations: snake_case with descriptive names
  - Routes: kebab-case URLs

### Livewire Conventions
- Use Livewire 3 syntax and patterns
- Component classes in `app/Livewire/` with organized subdirectories
- Form objects in `app/Livewire/Forms/` (e.g., `ScheduledEventFormObject`)
- Follow the pattern: `AdminScheduledEventsDashboard` for admin components
- Use protected properties with proper visibility
- Implement proper validation in form objects

### Database Conventions
- Use descriptive migration names
- Follow Laravel's table naming conventions
- Use proper foreign key relationships
- Cast dates properly (using `DateCast::class`)

## ✅ Testing Standards

- Use **Pest** for testing (not PHPUnit syntax) with clear, human-readable test names.
- Use **factories** for test data setup.
- Include feature tests for user-facing functionality.
- Include unit tests for business logic, services, and helper classes.
- Use descriptive test names that explain the scenario
- Prefer `it` syntax for Pest tests.


## Coding Preferences

### When Writing New Code
1. **Always use type hints** for parameters and return types
2. **Use proper validation** in Livewire forms
3. **Follow Laravel best practices** for database queries and relationships
4. **Write descriptive variable and method names**
5. **Use dependency injection** where appropriate
6. **Include proper docblocks** for complex methods

### When Suggesting Improvements
1. Prefer **Eloquent relationships** over raw queries
2. Use **resource controllers** for RESTful operations
3. Implement **proper error handling** and validation
4. Consider **performance implications** of queries
5. Suggest **caching strategies** where appropriate

### Security Considerations
- Always validate and sanitize user input
- Use Laravel's built-in CSRF protection
- Implement proper authorization with policies
- Follow Laravel security best practices
- Use mass assignment protection

## Common Task Patterns
- **Livewire Components**: Always include proper validation and error handling
- **API Endpoints**: Return consistent JSON responses with proper HTTP status codes
- **Database Queries**: Use Eloquent relationships and avoid N+1 problems
- **Form Handling**: Use Livewire form objects for complex forms
- **File Operations**: Use Laravel's Storage facade for file management

## Package-Specific Notes
- When using `naykel/*` packages, refer to their documentation for proper implementation
- `gotime` package likely provides date/time utilities - use its helpers for date operations
- `authit` package handles authentication - follow its patterns for user management
- `payit` package for payments - ensure proper error handling for payment operations

## Debugging and Development
- Use `barryvdh/laravel-debugbar` for debugging (already installed)
- Use `barryvdh/laravel-ide-helper` for better IDE support
- Use `dd()` and `dump()` for debugging
- Prefer logging errors to Laravel's log files

Remember: This is an educational platform, so prioritize user experience, data integrity, and security when making suggestions or writing code.
